## 문제

- 길이가 `n`이고, 오름차순으로 정렬된 정수 배열 `nums`가 있다.
- `nums`는 1 ~ `n`만큼 회전했다.
- 배열의 각 원소가 유니크한 값일 때, 원소 중 최소값을 구해라
    
    

## 해결

**********************************문제 해결 전략**********************************

- 기존 배열이 `k`만큼 회전했을 때, 이분탐색을 통해 `k`의 값을 구한다.
    - 만약, `nums[mid]` 보다 `nums[mid+1]`의 값이 더 작다면, `mid + 1`의 값이 회전한 값인 `k`이다.
        - 예를 들어, `[0, 1, 2, 3]`이 있을 때 `k`가 2라면 `[2, 3, 0, 1]`이다.
- 정답은 `nums[k]`가 된다.

### 1. 이진탐색

```java
class Solution {
    public int findMin(int[] nums) {
        int left = 0; int right = nums.length - 2;
        
        while (left <= right) {
            int mid = (left + right) / 2;

            if (nums[mid] > nums[mid + 1]) {
                return nums[mid + 1]; 
            }

            if (nums[left] > nums[mid]) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        
        return nums[0];
    }
}
```

1. `left`는 배열의 가장 왼쪽, `right`는 가장 오른쪽에서 하나 전 원소의 인덱스이다.
    1. `right`이 하나 전인 이유는 `nums[mid]`와 `nums[mid+1]`을 비교해서 경계 인덱스를 찾기 때문이다. 따라서 `nums`의 가장 마지막 원소는 탐색 범위에 포함되지 않는다. 
2. 만약 `nums[mid]`가 `nums[mid + 1]`보다 크다면, `mid+1`번 째 인덱스가 최솟값이기 때문에 반환한다.
3. `nums[left] > nums[mid]`라면, 왼쪽 배열은 회전을 한 배열이기 때문에 왼쪽 배열을 탐색하도록 설정한다.
4. `nums[left] <= nums[mid]`라면, 왼쪽 배열은 회전을 하지 않은 배열이기 때문에 오른쪽 배열을 탐색하도록 설정한다.
5. `while`문을 계속 돌면서 탐색 범위를 좁혀나가다가 회전한 배열이 없다면, 회전을 하지 않은 배열이기 때문에 `nums[0]`이 최솟값이므로 반환한다.

## 시간복잡도 & 공간복잡도

- 시간복잡도
    - 이진 탐색 : $O(logN)$
        - 배열을 반씩 쪼개서 탐색하기 때문이다.
- 공간복잡도
    - 이진 탐색 : $O(1)$
        - 추가적인 `N` 이상의 저장공간을 필요로 하지 않는다.
